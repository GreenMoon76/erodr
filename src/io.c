#undef _GNU_SOURCE // gets rid of vim warning
#define _GNU_SOURCE

#include "io.h"
#include <math.h>
#include <stdio.h> 
#include <stdlib.h>
#include <string.h>

/*
 * Parses command line arguments.
 */
int parse_args(int argc, char *argv[], char *filepath) {
	if (argc == 1) {
		printf("Usage: erodr FILE\n");
		return 1;	
	} else {
		filepath = strncpy(filepath, argv[1], FILEPATH_MAXLEN);
		return 0;
	}
}

/*
 * Loads *.pgm into buffer `buffer`. `buffer` is dynamically allocated in 
 * load_pgm and should be free'd after use.
 */
int load_pgm(
		const char *filepath,
	   	double **buffer,
	   	int *width,
	   	int *height,
		int *precision
) {
	FILE	*fp = fopen(filepath, "r");
	char	*token;
	char	*line = NULL;
	size_t	len = 0;

	if(fp == NULL)
		return 1;
	
	// read width, height and precision
	// TODO do properly
	if (getline(&line, &len, fp) == EOF) return 1; // magic
	if (getline(&line, &len, fp) == EOF) return 1; // comment
	if (getline(&line, &len, fp) == EOF) return 1; // width height
	token   = strtok(line, " ");
	*width  = atoi(token);
	token   = strtok(NULL, " ");
	*height = atoi(token);
	if (getline(&line, &len, fp) == EOF) return 1; // precision
	*precision = atoi(line);
		
	//allocate heightmap
	*buffer = (double*)malloc(sizeof(double) * (*height) * (*width));
	if(*buffer == NULL)
		return 1;

	// read heightmap values
	int i = 0;
	for(; getline(&line, &len, fp) != EOF; i++) {
		(*buffer)[i] = atof(line) / *precision;
	}
	
	fclose(fp);
	if(line)
		free(line);

	return 0;
}

/*
 * Saves buffer `buffer` to a file.
 */
int save_pgm(
		const char *filepath,
	   	double *buffer,
	   	int width,
	   	int height,
		int precision
) {
	FILE *fp = fopen(filepath, "w");

	// write "header"
	fputs("P2\n", fp);	
	fputs("# Generated by erodr\n", fp);
	fprintf(fp, "%d %d\n", width, height);	
	fprintf(fp, "%d\n", precision);	
	
	for(int i = 0; i < width * height; i++) {
		//fprintf(fp, "%d\n", (int)max(round(heightmap[i]*10000), 0));	
		fprintf(fp, "%d\n", (int)round(buffer[i]*precision));	
	}	
	fclose(fp);
	
	return 0;
}

