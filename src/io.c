#undef _GNU_SOURCE // gets rid of vim warning
#define _GNU_SOURCE

#include "io.h"
#include <math.h>
#include <stdio.h> 
#include <stdint.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

/*
 * Parses command line arguments.
 */
int parse_args(int argc, char *argv[], char *filepath) {
	if (argc == 1) {
		printf("Usage: erodr FILE\n");
		return 1;	
	} else {
		filepath = strncpy(filepath, argv[1], FILEPATH_MAXLEN);
		return 0;
	}
}

/*
 * Loads *.pgm into buffer `buffer`. `buffer` is dynamically allocated in 
 * load_pgm and should be free'd after use.
 */
int load_pgm(
		const char *filepath,
	   	double **buffer,
	   	int *width,
	   	int *height,
		int *precision
) {
	FILE	*fp = fopen(filepath, "r");
	char	*token;
	char	*line = NULL;
	char	*magic;
	size_t	len = 0;
	int		data_offset = 0;

	if(fp == NULL)
		return 1;
	
	// read width, height and precision
	// TODO rewrite properly
	if (getline(&magic, &len, fp) == EOF) return 1; // magic
	data_offset += len;
	if (getline(&line, &len, fp) == EOF) return 1; // comment
	data_offset += len;
	if (getline(&line, &len, fp) == EOF) return 1; // width height
	data_offset += len;
	token   = strtok(line, " ");
	*width  = atoi(token);
	token   = strtok(NULL, " ");
	*height = atoi(token);
	if (getline(&line, &len, fp) == EOF) return 1; // precision
	data_offset += len;
	*precision = atoi(line);
	
	// Allocate buffer for pixel values
	*buffer = (double*)malloc(sizeof(double) * (*height) * (*width));
	if(*buffer == NULL)
		return 1;

	// Read pixel values to buffer. 
	// If magic is "P2" then values are ASCII encoded. 
	// If magic is "P5" then values are binary encoded. 
	if(strncmp(magic, "P2", 2) == 0){
		for(int i = 0; getline(&line, &len, fp) != EOF; i++)
			(*buffer)[i] = atof(line) / *precision;
	} else if(strncmp(magic, "P5", 2) == 0) {
		int byte_depth = *precision < 256 ? 1 : 2; 
		char data[byte_depth];
		for(int i = 0; i < (*width)*(*height); i++) {
			fread(data, sizeof(char), byte_depth, fp);
			int val = (byte_depth == 2) ? 
				((data[0] << 8) & 0xFF00) | (data[1] & 0x00FF) :
				data[0] & 0xFF;
			(*buffer)[i] = (double) val / *precision;
		}
	}

	fclose(fp);
	if(line)
		free(line);

	return 0;
}

/*
 * Saves buffer `buffer` to a file.
 */
int save_pgm(
		const char *filepath,
	   	double *buffer,
	   	int width,
	   	int height,
		int precision,
		bool ascii_encoding
) {
	FILE *fp = fopen(filepath, "w");

	// write "header"
	fputs((ascii_encoding) ? "P2\n" : "P5\n", fp);	
	fputs("# Generated by erodr\n", fp);
	fprintf(fp, "%d %d\n", width, height);	
	fprintf(fp, "%d\n", precision);	

	if (ascii_encoding) {	
		for(int i = 0; i < width * height; i++) {
			fprintf(fp, "%d\n", (int)round(buffer[i]*precision));	
		}
	} else {
		char data[sizeof(uint16_t) * width * height];
		for(int i = 0; i < width * height; i++) {
			int gv = (uint16_t)round(buffer[i]*precision);
			data[2 * i]		= (gv >> 8) & 0xFF;
			data[2 * i + 1] = gv & 0xFF;
		}
		fwrite(data, sizeof(uint16_t), width * height, fp); 
	}	
	fclose(fp);
	
	return 0;
}

